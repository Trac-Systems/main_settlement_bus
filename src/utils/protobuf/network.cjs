var b4a = require('b4a');
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

exports.MessageType = {
  "MESSAGE_TYPE_UNSPECIFIED": 0,
  "MESSAGE_TYPE_LIVENESS_REQUEST": 1,
  "MESSAGE_TYPE_LIVENESS_RESPONSE": 2,
  "MESSAGE_TYPE_BROADCAST_TRANSACTION_REQUEST": 3,
  "MESSAGE_TYPE_BROADCAST_TRANSACTION_RESPONSE": 4
}

exports.ResultCode = {
  "RESULT_CODE_UNSPECIFIED": 0,
  "RESULT_CODE_OK": 1,
  "RESULT_CODE_INVALID_PAYLOAD": 2,
  "RESULT_CODE_RATE_LIMITED": 3,
  "RESULT_CODE_SIGNATURE_INVALID": 4,
  "RESULT_CODE_UNEXPECTED_ERROR": 5,
  "RESULT_CODE_TIMEOUT": 6,
  "RESULT_CODE_NODE_HAS_NO_WRITE_ACCESS": 7,
  "RESULT_CODE_TX_ACCEPTED_PROOF_UNAVAILABLE": 8,
  "RESULT_CODE_NODE_OVERLOADED": 9,
  "RESULT_CODE_TX_ALREADY_PENDING": 10,
  "RESULT_CODE_OPERATION_TYPE_UNKNOWN": 11,
  "RESULT_CODE_SCHEMA_VALIDATION_FAILED": 12,
  "RESULT_CODE_REQUESTER_ADDRESS_INVALID": 13,
  "RESULT_CODE_REQUESTER_PUBLIC_KEY_INVALID": 14,
  "RESULT_CODE_TX_HASH_MISMATCH": 15,
  "RESULT_CODE_TX_SIGNATURE_INVALID": 16,
  "RESULT_CODE_TX_EXPIRED": 17,
  "RESULT_CODE_TX_ALREADY_EXISTS": 18,
  "RESULT_CODE_OPERATION_ALREADY_COMPLETED": 19,
  "RESULT_CODE_REQUESTER_NOT_FOUND": 20,
  "RESULT_CODE_INSUFFICIENT_FEE_BALANCE": 21,
  "RESULT_CODE_EXTERNAL_BOOTSTRAP_EQUALS_MSB_BOOTSTRAP": 22,
  "RESULT_CODE_SELF_VALIDATION_FORBIDDEN": 23,
  "RESULT_CODE_ROLE_NODE_ENTRY_NOT_FOUND": 24,
  "RESULT_CODE_ROLE_NODE_ALREADY_WRITER": 25,
  "RESULT_CODE_ROLE_NODE_NOT_WHITELISTED": 26,
  "RESULT_CODE_ROLE_NODE_NOT_WRITER": 27,
  "RESULT_CODE_ROLE_NODE_IS_INDEXER": 28,
  "RESULT_CODE_ROLE_ADMIN_ENTRY_MISSING": 29,
  "RESULT_CODE_ROLE_INVALID_RECOVERY_CASE": 30,
  "RESULT_CODE_ROLE_UNKNOWN_OPERATION": 31,
  "RESULT_CODE_ROLE_INVALID_WRITER_KEY": 32,
  "RESULT_CODE_ROLE_INSUFFICIENT_FEE_BALANCE": 33,
  "RESULT_CODE_MSB_BOOTSTRAP_MISMATCH": 34,
  "RESULT_CODE_EXTERNAL_BOOTSTRAP_NOT_DEPLOYED": 35,
  "RESULT_CODE_EXTERNAL_BOOTSTRAP_TX_MISSING": 36,
  "RESULT_CODE_EXTERNAL_BOOTSTRAP_MISMATCH": 37,
  "RESULT_CODE_BOOTSTRAP_ALREADY_EXISTS": 38,
  "RESULT_CODE_TRANSFER_RECIPIENT_ADDRESS_INVALID": 39,
  "RESULT_CODE_TRANSFER_RECIPIENT_PUBLIC_KEY_INVALID": 40,
  "RESULT_CODE_TRANSFER_AMOUNT_TOO_LARGE": 41,
  "RESULT_CODE_TRANSFER_SENDER_NOT_FOUND": 42,
  "RESULT_CODE_TRANSFER_INSUFFICIENT_BALANCE": 43,
  "RESULT_CODE_TRANSFER_RECIPIENT_BALANCE_OVERFLOW": 44,
  "RESULT_CODE_TX_HASH_INVALID_FORMAT": 45,
  "RESULT_CODE_INTERNAL_ENQUEUE_VALIDATION_FAILED": 46,
  "RESULT_CODE_TX_ACCEPTED_RECEIPT_MISSING": 47,
  "RESULT_CODE_VALIDATOR_RESPONSE_TX_TYPE_INVALID": 48,
  "RESULT_CODE_VALIDATOR_RESPONSE_TX_TYPE_UNKNOWN": 49,
  "RESULT_CODE_VALIDATOR_RESPONSE_TX_TYPE_UNSUPPORTED": 50,
  "RESULT_CODE_VALIDATOR_RESPONSE_SCHEMA_INVALID": 51,
  "RESULT_CODE_PENDING_REQUEST_MISSING_TX_DATA": 52,
  "RESULT_CODE_PROOF_PAYLOAD_MISMATCH": 53,
  "RESULT_CODE_VALIDATOR_WRITER_KEY_NOT_REGISTERED": 54,
  "RESULT_CODE_VALIDATOR_ADDRESS_MISMATCH": 55,
  "RESULT_CODE_VALIDATOR_NODE_ENTRY_NOT_FOUND": 56,
  "RESULT_CODE_VALIDATOR_NODE_NOT_WRITER": 57,
  "RESULT_CODE_VALIDATOR_WRITER_KEY_MISMATCH": 58,
  "RESULT_CODE_VALIDATOR_TX_OBJECT_INVALID": 59,
  "RESULT_CODE_VALIDATOR_VA_MISSING": 60
}

var LivenessRequest = exports.LivenessRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LivenessResponse = exports.LivenessResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var BroadcastTransactionRequest = exports.BroadcastTransactionRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var BroadcastTransactionResponse = exports.BroadcastTransactionResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ProofData = exports.ProofData = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MessageHeader = exports.MessageHeader = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineLivenessRequest()
defineLivenessResponse()
defineBroadcastTransactionRequest()
defineBroadcastTransactionResponse()
defineProofData()
defineMessageHeader()

function defineLivenessRequest () {
  LivenessRequest.encodingLength = encodingLength
  LivenessRequest.encode = encode
  LivenessRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLivenessResponse () {
  LivenessResponse.encodingLength = encodingLength
  LivenessResponse.encode = encode
  LivenessResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    if (defined(obj.result)) {
      var len = encodings.enum.encodingLength(obj.result)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.result)) {
      buf[offset++] = 24
      encodings.enum.encode(obj.result, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null,
      result: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.result = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineBroadcastTransactionRequest () {
  BroadcastTransactionRequest.encodingLength = encodingLength
  BroadcastTransactionRequest.encode = encode
  BroadcastTransactionRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.data)) {
      var len = encodings.bytes.encodingLength(obj.data)
      length += 1 + len
    }
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.data)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.nonce)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      data: null,
      nonce: null,
      signature: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineBroadcastTransactionResponse () {
  BroadcastTransactionResponse.encodingLength = encodingLength
  BroadcastTransactionResponse.encode = encode
  BroadcastTransactionResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    if (defined(obj.proof)) {
      var len = encodings.bytes.encodingLength(obj.proof)
      length += 1 + len
    }
    if (defined(obj.appendedAt)) {
      var len = encodings.varint.encodingLength(obj.appendedAt)
      length += 1 + len
    }
    if (defined(obj.result)) {
      var len = encodings.enum.encodingLength(obj.result)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.proof)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.proof, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.appendedAt)) {
      buf[offset++] = 32
      encodings.varint.encode(obj.appendedAt, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.result)) {
      buf[offset++] = 40
      encodings.enum.encode(obj.result, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null,
      proof: null,
      appendedAt: 0,
      result: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.proof = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 4:
        obj.appendedAt = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 5:
        obj.result = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineProofData () {
  ProofData.encodingLength = encodingLength
  ProofData.encode = encode
  ProofData.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.proof)) {
      var len = encodings.bytes.encodingLength(obj.proof)
      length += 1 + len
    }
    if (defined(obj.appendedAt)) {
      var len = encodings.varint.encodingLength(obj.appendedAt)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.proof)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.proof, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.appendedAt)) {
      buf[offset++] = 16
      encodings.varint.encode(obj.appendedAt, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      proof: null,
      appendedAt: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.proof = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.appendedAt = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMessageHeader () {
  MessageHeader.encodingLength = encodingLength
  MessageHeader.encode = encode
  MessageHeader.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.liveness_request) + +defined(obj.liveness_response) + +defined(obj.broadcast_transaction_request) + +defined(obj.broadcast_transaction_response)) > 1) throw new Error("only one of the properties defined in oneof field can be set")
    if (defined(obj.type)) {
      var len = encodings.enum.encodingLength(obj.type)
      length += 1 + len
    }
    if (defined(obj.id)) {
      var len = encodings.string.encodingLength(obj.id)
      length += 1 + len
    }
    if (defined(obj.timestamp)) {
      var len = encodings.varint.encodingLength(obj.timestamp)
      length += 1 + len
    }
    if (defined(obj.liveness_request)) {
      var len = LivenessRequest.encodingLength(obj.liveness_request)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.liveness_response)) {
      var len = LivenessResponse.encodingLength(obj.liveness_response)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.broadcast_transaction_request)) {
      var len = BroadcastTransactionRequest.encodingLength(obj.broadcast_transaction_request)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.broadcast_transaction_response)) {
      var len = BroadcastTransactionResponse.encodingLength(obj.broadcast_transaction_response)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.capabilities)) {
      for (var i = 0; i < obj.capabilities.length; i++) {
        if (!defined(obj.capabilities[i])) continue
        var len = encodings.string.encodingLength(obj.capabilities[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.liveness_request) + +defined(obj.liveness_response) + +defined(obj.broadcast_transaction_request) + +defined(obj.broadcast_transaction_response)) > 1) throw new Error("only one of the properties defined in oneof field can be set")
    if (defined(obj.type)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.type, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.id)) {
      buf[offset++] = 18
      encodings.string.encode(obj.id, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.timestamp)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.timestamp, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.liveness_request)) {
      buf[offset++] = 34
      varint.encode(LivenessRequest.encodingLength(obj.liveness_request), buf, offset)
      offset += varint.encode.bytes
      LivenessRequest.encode(obj.liveness_request, buf, offset)
      offset += LivenessRequest.encode.bytes
    }
    if (defined(obj.liveness_response)) {
      buf[offset++] = 42
      varint.encode(LivenessResponse.encodingLength(obj.liveness_response), buf, offset)
      offset += varint.encode.bytes
      LivenessResponse.encode(obj.liveness_response, buf, offset)
      offset += LivenessResponse.encode.bytes
    }
    if (defined(obj.broadcast_transaction_request)) {
      buf[offset++] = 50
      varint.encode(BroadcastTransactionRequest.encodingLength(obj.broadcast_transaction_request), buf, offset)
      offset += varint.encode.bytes
      BroadcastTransactionRequest.encode(obj.broadcast_transaction_request, buf, offset)
      offset += BroadcastTransactionRequest.encode.bytes
    }
    if (defined(obj.broadcast_transaction_response)) {
      buf[offset++] = 58
      varint.encode(BroadcastTransactionResponse.encodingLength(obj.broadcast_transaction_response), buf, offset)
      offset += varint.encode.bytes
      BroadcastTransactionResponse.encode(obj.broadcast_transaction_response, buf, offset)
      offset += BroadcastTransactionResponse.encode.bytes
    }
    if (defined(obj.capabilities)) {
      for (var i = 0; i < obj.capabilities.length; i++) {
        if (!defined(obj.capabilities[i])) continue
        buf[offset++] = 66
        encodings.string.encode(obj.capabilities[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      type: 0,
      id: "",
      timestamp: 0,
      liveness_request: null,
      liveness_response: null,
      broadcast_transaction_request: null,
      broadcast_transaction_response: null,
      capabilities: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.type = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        obj.id = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.timestamp = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 4:
        delete obj.liveness_response
        delete obj.broadcast_transaction_request
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.liveness_request = LivenessRequest.decode(buf, offset, offset + len)
        offset += LivenessRequest.decode.bytes
        break
        case 5:
        delete obj.liveness_request
        delete obj.broadcast_transaction_request
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.liveness_response = LivenessResponse.decode(buf, offset, offset + len)
        offset += LivenessResponse.decode.bytes
        break
        case 6:
        delete obj.liveness_request
        delete obj.liveness_response
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.broadcast_transaction_request = BroadcastTransactionRequest.decode(buf, offset, offset + len)
        offset += BroadcastTransactionRequest.decode.bytes
        break
        case 7:
        delete obj.liveness_request
        delete obj.liveness_response
        delete obj.broadcast_transaction_request
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.broadcast_transaction_response = BroadcastTransactionResponse.decode(buf, offset, offset + len)
        offset += BroadcastTransactionResponse.decode.bytes
        break
        case 8:
        obj.capabilities.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
