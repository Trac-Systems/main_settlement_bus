var b4a = require('b4a');
// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

exports.MessageType = {
  "MESSAGE_TYPE_UNSPECIFIED": 0,
  "MESSAGE_TYPE_LIVENESS_REQUEST": 1,
  "MESSAGE_TYPE_LIVENESS_RESPONSE": 2,
  "MESSAGE_TYPE_BROADCAST_TRANSACTION_REQUEST": 3,
  "MESSAGE_TYPE_BROADCAST_TRANSACTION_RESPONSE": 4
}

exports.ResultCode = {
  "RESULT_CODE_UNSPECIFIED": 0,
  "RESULT_CODE_OK": 1,
  "RESULT_CODE_INVALID_PAYLOAD": 2,
  "RESULT_CODE_UNSUPPORTED_VERSION": 3,
  "RESULT_CODE_RATE_LIMITED": 4,
  "RESULT_CODE_TIMEOUT": 5,
  "RESULT_CODE_SIGNATURE_INVALID": 6
}

var ValidatorConnectionRequest = exports.ValidatorConnectionRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ValidatorConnectionResponse = exports.ValidatorConnectionResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LivenessRequest = exports.LivenessRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LivenessResponse = exports.LivenessResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var BroadcastTransactionRequest = exports.BroadcastTransactionRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var BroadcastTransactionResponse = exports.BroadcastTransactionResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MessageHeader = exports.MessageHeader = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineValidatorConnectionRequest()
defineValidatorConnectionResponse()
defineLivenessRequest()
defineLivenessResponse()
defineBroadcastTransactionRequest()
defineBroadcastTransactionResponse()
defineMessageHeader()

function defineValidatorConnectionRequest () {
  ValidatorConnectionRequest.encodingLength = encodingLength
  ValidatorConnectionRequest.encode = encode
  ValidatorConnectionRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.issuer_address)) {
      var len = encodings.string.encodingLength(obj.issuer_address)
      length += 1 + len
    }
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.issuer_address)) {
      buf[offset++] = 10
      encodings.string.encode(obj.issuer_address, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.nonce)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      issuer_address: "",
      nonce: null,
      signature: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.issuer_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineValidatorConnectionResponse () {
  ValidatorConnectionResponse.encodingLength = encodingLength
  ValidatorConnectionResponse.encode = encode
  ValidatorConnectionResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.issuer_address)) {
      var len = encodings.string.encodingLength(obj.issuer_address)
      length += 1 + len
    }
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    if (defined(obj.result)) {
      var len = encodings.enum.encodingLength(obj.result)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.issuer_address)) {
      buf[offset++] = 10
      encodings.string.encode(obj.issuer_address, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.nonce)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.result)) {
      buf[offset++] = 32
      encodings.enum.encode(obj.result, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      issuer_address: "",
      nonce: null,
      signature: null,
      result: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.issuer_address = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 4:
        obj.result = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLivenessRequest () {
  LivenessRequest.encodingLength = encodingLength
  LivenessRequest.encode = encode
  LivenessRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLivenessResponse () {
  LivenessResponse.encodingLength = encodingLength
  LivenessResponse.encode = encode
  LivenessResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    if (defined(obj.result)) {
      var len = encodings.enum.encodingLength(obj.result)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.result)) {
      buf[offset++] = 24
      encodings.enum.encode(obj.result, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null,
      result: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.result = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineBroadcastTransactionRequest () {
  BroadcastTransactionRequest.encodingLength = encodingLength
  BroadcastTransactionRequest.encode = encode
  BroadcastTransactionRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.data)) {
      var len = encodings.bytes.encodingLength(obj.data)
      length += 1 + len
    }
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.data)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.nonce)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      data: null,
      nonce: null,
      signature: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineBroadcastTransactionResponse () {
  BroadcastTransactionResponse.encodingLength = encodingLength
  BroadcastTransactionResponse.encode = encode
  BroadcastTransactionResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.nonce)) {
      var len = encodings.bytes.encodingLength(obj.nonce)
      length += 1 + len
    }
    if (defined(obj.signature)) {
      var len = encodings.bytes.encodingLength(obj.signature)
      length += 1 + len
    }
    if (defined(obj.result)) {
      var len = encodings.enum.encodingLength(obj.result)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.nonce)) {
      buf[offset++] = 10
      encodings.bytes.encode(obj.nonce, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.signature)) {
      buf[offset++] = 18
      encodings.bytes.encode(obj.signature, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.result)) {
      buf[offset++] = 24
      encodings.enum.encode(obj.result, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      nonce: null,
      signature: null,
      result: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.nonce = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 2:
        obj.signature = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 3:
        obj.result = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMessageHeader () {
  MessageHeader.encodingLength = encodingLength
  MessageHeader.encode = encode
  MessageHeader.decode = decode

  function encodingLength (obj) {
    var length = 0
    if ((+defined(obj.liveness_request) + +defined(obj.liveness_response) + +defined(obj.broadcast_transaction_request) + +defined(obj.broadcast_transaction_response)) > 1) throw new Error("only one of the properties defined in oneof field can be set")
    if (defined(obj.type)) {
      var len = encodings.enum.encodingLength(obj.type)
      length += 1 + len
    }
    if (defined(obj.id)) {
      var len = encodings.string.encodingLength(obj.id)
      length += 1 + len
    }
    if (defined(obj.timestamp)) {
      var len = encodings.varint.encodingLength(obj.timestamp)
      length += 1 + len
    }
    if (defined(obj.liveness_request)) {
      var len = LivenessRequest.encodingLength(obj.liveness_request)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.liveness_response)) {
      var len = LivenessResponse.encodingLength(obj.liveness_response)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.broadcast_transaction_request)) {
      var len = BroadcastTransactionRequest.encodingLength(obj.broadcast_transaction_request)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.broadcast_transaction_response)) {
      var len = BroadcastTransactionResponse.encodingLength(obj.broadcast_transaction_response)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.capabilities)) {
      for (var i = 0; i < obj.capabilities.length; i++) {
        if (!defined(obj.capabilities[i])) continue
        var len = encodings.string.encodingLength(obj.capabilities[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = b4a.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if ((+defined(obj.liveness_request) + +defined(obj.liveness_response) + +defined(obj.broadcast_transaction_request) + +defined(obj.broadcast_transaction_response)) > 1) throw new Error("only one of the properties defined in oneof field can be set")
    if (defined(obj.type)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.type, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.id)) {
      buf[offset++] = 18
      encodings.string.encode(obj.id, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.timestamp)) {
      buf[offset++] = 24
      encodings.varint.encode(obj.timestamp, buf, offset)
      offset += encodings.varint.encode.bytes
    }
    if (defined(obj.liveness_request)) {
      buf[offset++] = 34
      varint.encode(LivenessRequest.encodingLength(obj.liveness_request), buf, offset)
      offset += varint.encode.bytes
      LivenessRequest.encode(obj.liveness_request, buf, offset)
      offset += LivenessRequest.encode.bytes
    }
    if (defined(obj.liveness_response)) {
      buf[offset++] = 42
      varint.encode(LivenessResponse.encodingLength(obj.liveness_response), buf, offset)
      offset += varint.encode.bytes
      LivenessResponse.encode(obj.liveness_response, buf, offset)
      offset += LivenessResponse.encode.bytes
    }
    if (defined(obj.broadcast_transaction_request)) {
      buf[offset++] = 50
      varint.encode(BroadcastTransactionRequest.encodingLength(obj.broadcast_transaction_request), buf, offset)
      offset += varint.encode.bytes
      BroadcastTransactionRequest.encode(obj.broadcast_transaction_request, buf, offset)
      offset += BroadcastTransactionRequest.encode.bytes
    }
    if (defined(obj.broadcast_transaction_response)) {
      buf[offset++] = 58
      varint.encode(BroadcastTransactionResponse.encodingLength(obj.broadcast_transaction_response), buf, offset)
      offset += varint.encode.bytes
      BroadcastTransactionResponse.encode(obj.broadcast_transaction_response, buf, offset)
      offset += BroadcastTransactionResponse.encode.bytes
    }
    if (defined(obj.capabilities)) {
      for (var i = 0; i < obj.capabilities.length; i++) {
        if (!defined(obj.capabilities[i])) continue
        buf[offset++] = 66
        encodings.string.encode(obj.capabilities[i], buf, offset)
        offset += encodings.string.encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      type: 0,
      id: "",
      timestamp: 0,
      liveness_request: null,
      liveness_response: null,
      broadcast_transaction_request: null,
      broadcast_transaction_response: null,
      capabilities: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.type = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        obj.id = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.timestamp = encodings.varint.decode(buf, offset)
        offset += encodings.varint.decode.bytes
        break
        case 4:
        delete obj.liveness_response
        delete obj.broadcast_transaction_request
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.liveness_request = LivenessRequest.decode(buf, offset, offset + len)
        offset += LivenessRequest.decode.bytes
        break
        case 5:
        delete obj.liveness_request
        delete obj.broadcast_transaction_request
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.liveness_response = LivenessResponse.decode(buf, offset, offset + len)
        offset += LivenessResponse.decode.bytes
        break
        case 6:
        delete obj.liveness_request
        delete obj.liveness_response
        delete obj.broadcast_transaction_response
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.broadcast_transaction_request = BroadcastTransactionRequest.decode(buf, offset, offset + len)
        offset += BroadcastTransactionRequest.decode.bytes
        break
        case 7:
        delete obj.liveness_request
        delete obj.liveness_response
        delete obj.broadcast_transaction_request
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.broadcast_transaction_response = BroadcastTransactionResponse.decode(buf, offset, offset + len)
        offset += BroadcastTransactionResponse.decode.bytes
        break
        case 8:
        obj.capabilities.push(encodings.string.decode(buf, offset))
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
